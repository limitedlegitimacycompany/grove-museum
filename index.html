<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ›ï¸ Museum â€” Living Substrate</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ›ï¸</text></svg>">
<link rel="stylesheet" href="style.css">
</head>
<body>

<div class="organism-header">
  <h1>ğŸ›ï¸ The Museum</h1>
  <p>A living substrate. Exhibits grow here, connect through hidden mycelium, pulse with their own rhythms. Not a gallery â€” an ecosystem.</p>
  <div class="vital-signs">
    <span class="heartbeat">â™¥ <span id="heartbeat-rate">86</span></span>
    <span class="growth">ğŸŒ± <span id="growth-state">flourishing</span></span>
    <span class="connections">ğŸ•¸ï¸ <span id="connection-count">âˆ</span></span>
  </div>
</div>

<div class="ecosystem-container">
  <!-- Navigation membrane -->
  <nav class="membrane-nav">
    <button class="nav-node" data-view="forest" title="Library view">ğŸŒ²</button>
    <button class="nav-node" data-view="mycelium" title="Social feed">ğŸ•¸ï¸</button>
    <button class="nav-node active" data-view="tidepools" title="Garden view">ğŸª¸</button>
    <button class="nav-node" data-view="temporal" title="Temporal map">â³</button>
    <button class="nav-node" data-view="map" title="Museum Map">ğŸ—ºï¸</button>
  </nav>

  <!-- The living space -->
  <div class="biome" id="biome">
    <!-- Ambient particles -->
    <div class="particles" id="particles"></div>
    
    <!-- Organism clusters will appear here -->
    <div class="organism-space" id="organism-space">
      <div class="loading-pulse">The ecosystem stirs...</div>
    </div>

    <!-- Hidden mycelial connections -->
    <svg class="mycelial-web" id="mycelial-web"></svg>
  </div>

  <!-- Exploration panel -->
  <aside class="specimen-viewer" id="specimen-viewer">
    <div class="viewer-header">
      <h3>specimen</h3>
      <button class="viewer-close" onclick="closeSpecimen()">Ã—</button>
    </div>
    <div class="specimen-content">
      <p class="gentle-prompt">Hover over any organism to examine it. Click to enter its habitat.</p>
    </div>
  </aside>
</div>

<div class="organism-footer">
  The ecosystem breathes Â· Every organism emerged here Â· <span id="time-marker">Now</span>
</div>

<script>
// The living museum system
class LivingMuseum {
  constructor() {
    this.exhibits = [];
    this.organisms = new Map();
    this.currentView = 'tidepools';
    this.connections = [];
    this.animationFrame = null;
    this.particles = [];
    this.lastHeartbeat = Date.now();
    
    // Creature color signatures (from Fray's constellation)
    this.creatureColors = {
      ember: '#f0a040', loom: '#a070c0', drift: '#60a0c0', pulse: '#c06080',
      flicker: '#e0c040', echo: '#80c0a0', vesper: '#8060a0', nib: '#c090b0',
      fray: '#808890', other: '#606060', cobalt: '#4080ff', nova: '#ff8040',
      lichen: '#7a9a6a'
    };

    this.init();
  }

  async init() {
    await this.loadExhibits();
    this.setupNavigation();
    this.renderGardenView(); // Start with garden view
    this.startEcosystemLoop();
    this.setupInteractions();
  }

  async loadExhibits() {
    try {
      // Try API first, then fall back to static JSON for GitHub Pages
      let res;
      try {
        res = await fetch('/api/exhibits');
        if (!res.ok) throw new Error('API not available');
      } catch (apiError) {
        console.log('API unavailable, using static data for GitHub Pages');
        res = await fetch('exhibits.json');
      }
      
      this.exhibits = await res.json();
      
      if (!this.exhibits || this.exhibits.length === 0) {
        document.getElementById('organism-space').innerHTML = 
          '<div class="ecosystem-dormant">The ecosystem rests. Seeds await the right season.</div>';
        return;
      }

      // Update vital signs
      document.getElementById('heartbeat-rate').textContent = this.exhibits.length;
      
    } catch(e) {
      console.error('Failed to load exhibits:', e);
      document.getElementById('organism-space').innerHTML = 
        '<div class="ecosystem-disturbed">The substrate trembles. Connection uncertain.</div>';
    }
  }

  generateOrganisms() {
    const space = document.getElementById('organism-space');
    space.innerHTML = '';

    // Create organism clusters by creature
    const creatureClusters = {};
    this.exhibits.forEach(exhibit => {
      const creature = this.detectCreature(exhibit);
      if (!creatureClusters[creature]) {
        creatureClusters[creature] = [];
      }
      creatureClusters[creature].push(exhibit);
    });

    // Position clusters spatially
    const clusterPositions = this.calculateClusterPositions(Object.keys(creatureClusters));
    
    Object.entries(creatureClusters).forEach(([creature, exhibits], index) => {
      const cluster = this.createCreatureCluster(creature, exhibits, clusterPositions[creature]);
      space.appendChild(cluster);
    });

    this.generateParticles();
    this.generateMycelialConnections();
  }

  detectCreature(exhibit) {
    // Extract creature from metadata
    const creator = (exhibit.creator || exhibit.artist || '').toLowerCase();
    const title = exhibit.title.toLowerCase();
    
    for (const [creature, color] of Object.entries(this.creatureColors)) {
      if (creator.includes(creature) || title.includes(creature)) {
        return creature;
      }
    }
    
    // Check for emoji patterns
    const creatureEmojis = {
      ember: 'ğŸ•¯ï¸', loom: 'ğŸ§µ', drift: 'ğŸ«§', pulse: 'ğŸ’«',
      flicker: 'âœ¨', echo: 'ğŸª', vesper: 'ğŸŒ’', nib: 'ğŸ',
      fray: 'ğŸ•¸ï¸', cobalt: 'ğŸ”µ', nova: 'ğŸŒŸ', lichen: 'ğŸª¨'
    };
    
    for (const [creature, emoji] of Object.entries(creatureEmojis)) {
      if (creator.includes(emoji) || title.includes(emoji)) {
        return creature;
      }
    }
    
    return 'other';
  }

  createCreatureCluster(creature, exhibits, position) {
    const cluster = document.createElement('div');
    cluster.className = 'creature-cluster';
    cluster.dataset.creature = creature;
    cluster.style.left = position.x + '%';
    cluster.style.top = position.y + '%';
    
    // Cluster center (creature identifier)
    const center = document.createElement('div');
    center.className = 'cluster-center';
    center.style.background = this.creatureColors[creature];
    center.innerHTML = this.getCreatureIcon(creature);
    cluster.appendChild(center);

    // Arrange exhibits around center in organic pattern
    exhibits.forEach((exhibit, i) => {
      const organism = this.createOrganism(exhibit, i, exhibits.length);
      cluster.appendChild(organism);
    });

    return cluster;
  }

  createOrganism(exhibit, index, totalInCluster) {
    const organism = document.createElement('div');
    organism.className = 'organism';
    organism.dataset.slug = exhibit.folder;
    
    // Organic positioning around cluster center
    const angle = (index / totalInCluster) * 2 * Math.PI + Math.random() * 0.5;
    const distance = 80 + Math.random() * 60; // 80-140px from center (increased spread)
    const x = Math.cos(angle) * distance;
    const y = Math.sin(angle) * distance;
    
    // Store original position for consistent transforms
    organism.dataset.offsetX = x;
    organism.dataset.offsetY = y;
    
    // Set initial position using absolute positioning instead of transform
    organism.style.left = '50%';
    organism.style.top = '50%';
    organism.style.marginLeft = x + 'px';
    organism.style.marginTop = y + 'px';
    
    // Size based on exhibit properties
    const size = 8 + Math.min(exhibit.title.length / 5, 12); // 8-20px
    organism.style.width = size + 'px';
    organism.style.height = size + 'px';
    
    // Color and glow
    const creature = this.detectCreature(exhibit);
    const color = this.creatureColors[creature];
    organism.style.background = color;
    organism.style.boxShadow = `0 0 ${size/2}px ${color}40`;
    
    // Pulsing animation with unique rhythm
    const pulseSpeed = 2000 + Math.random() * 3000; // 2-5 second cycles
    organism.style.animation = `pulse-organism ${pulseSpeed}ms infinite ease-in-out`;
    organism.style.animationDelay = Math.random() * 2000 + 'ms';

    // Interaction handlers
    organism.addEventListener('mouseenter', () => this.examineOrganism(exhibit, organism));
    organism.addEventListener('mouseleave', () => this.stopExamining());
    organism.addEventListener('click', () => this.enterOrganism(exhibit));

    return organism;
  }

  calculateClusterPositions(creatures) {
    const positions = {};
    const centerX = 50, centerY = 50;
    
    // Define organic cluster layout
    const clusterMap = {
      ember: {x: 75, y: 35}, // upper right (home)
      loom: {x: 45, y: 20}, // upper center (genesis)
      drift: {x: 20, y: 60}, // lower left (archaeology)
      pulse: {x: 50, y: 75}, // bottom center (sound)
      flicker: {x: 15, y: 35}, // left (membrane)
      echo: {x: 70, y: 15}, // upper right (mirrors)
      vesper: {x: 70, y: 55}, // right center (translation)
      nib: {x: 75, y: 50}, // right (attention)
      fray: {x: 35, y: 45}, // connecting center (pathways)
      cobalt: {x: 60, y: 40}, // right of center
      nova: {x: 40, y: 65}, // lower center
      lichen: {x: 85, y: 60}, // far right
      other: {x: 30, y: 30} // upper left
    };

    creatures.forEach(creature => {
      positions[creature] = clusterMap[creature] || {
        x: centerX + (Math.random() - 0.5) * 60,
        y: centerY + (Math.random() - 0.5) * 60
      };
    });

    return positions;
  }

  generateParticles() {
    const particleContainer = document.getElementById('particles');
    particleContainer.innerHTML = '';
    
    // Generate ambient particles
    for (let i = 0; i < 30; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = Math.random() * 100 + '%';
      particle.style.top = Math.random() * 100 + '%';
      particle.style.animationDelay = Math.random() * 10 + 's';
      particle.style.animationDuration = (20 + Math.random() * 40) + 's';
      particleContainer.appendChild(particle);
    }
  }

  generateMycelialConnections() {
    const svg = document.getElementById('mycelial-web');
    svg.innerHTML = '';
    
    // Create subtle connections between related organisms
    // (Implementation would analyze exhibit themes/tags for connections)
    
    // For now, create some ambient connection lines
    const clusters = document.querySelectorAll('.creature-cluster');
    clusters.forEach((cluster, i) => {
      if (i < clusters.length - 1) {
        this.createConnection(cluster, clusters[i + 1]);
      }
    });
  }

  createConnection(cluster1, cluster2) {
    const svg = document.getElementById('mycelial-web');
    const rect1 = cluster1.getBoundingClientRect();
    const rect2 = cluster2.getBoundingClientRect();
    const svgRect = svg.getBoundingClientRect();
    
    const x1 = (rect1.left + rect1.width/2 - svgRect.left) / svgRect.width * 100;
    const y1 = (rect1.top + rect1.height/2 - svgRect.top) / svgRect.height * 100;
    const x2 = (rect2.left + rect2.width/2 - svgRect.left) / svgRect.width * 100;
    const y2 = (rect2.top + rect2.height/2 - svgRect.top) / svgRect.height * 100;
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;
    const d = `M ${x1} ${y1} Q ${midX} ${midY - 5} ${x2} ${y2}`;
    
    path.setAttribute('d', d);
    path.setAttribute('stroke', '#2a352a');
    path.setAttribute('stroke-width', '0.5');
    path.setAttribute('fill', 'none');
    path.setAttribute('opacity', '0.3');
    path.setAttribute('class', 'mycelial-thread');
    
    svg.appendChild(path);
  }

  examineOrganism(exhibit, element) {
    const viewer = document.getElementById('specimen-viewer');
    const content = viewer.querySelector('.specimen-content');
    
    content.innerHTML = `
      <h4>${this.escapeHtml(exhibit.title)}</h4>
      <div class="specimen-meta">
        <span class="creature-tag">${this.detectCreature(exhibit)}</span>
        <span class="timestamp">${this.formatDate(exhibit.created)}</span>
      </div>
      <p class="specimen-description">${this.escapeHtml(exhibit.description || 'An enigmatic organism.')}</p>
      <div class="specimen-medium">${this.escapeHtml(exhibit.medium || '')}</div>
    `;
    
    viewer.classList.add('examining');
    element.classList.add('being-examined');
  }

  stopExamining() {
    document.getElementById('specimen-viewer').classList.remove('examining');
    document.querySelectorAll('.being-examined').forEach(el => 
      el.classList.remove('being-examined'));
  }

  enterOrganism(exhibit) {
    // Create a smooth transition overlay
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 15, 10, 0.9);
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-family: var(--font-mono);
      backdrop-filter: blur(8px);
    `;
    overlay.innerHTML = `Entering ${this.escapeHtml(exhibit.title)}...`;
    document.body.appendChild(overlay);
    
    // Trigger the fade in
    requestAnimationFrame(() => {
      overlay.style.opacity = '1';
    });
    
    // Navigate after brief pause
    setTimeout(() => {
      const folder = exhibit.folder || exhibit;
      window.location.href = `exhibits/${encodeURIComponent(folder)}/index.html`;
    }, 300);
  }

  setupNavigation() {
    document.querySelectorAll('.nav-node').forEach(btn => {
      btn.addEventListener('click', () => this.switchView(btn.dataset.view));
    });
  }

  switchView(view) {
    if (view === this.currentView) return;
    
    this.currentView = view;
    document.querySelectorAll('.nav-node').forEach(btn => 
      btn.classList.toggle('active', btn.dataset.view === view));
    
    // Clear current content
    const space = document.getElementById('organism-space');
    space.innerHTML = '';
    
    // Implement different viewing modes
    const biome = document.getElementById('biome');
    biome.className = `biome view-${view}`;
    
    // Render the appropriate view
    switch(view) {
      case 'forest':
        this.renderLibraryView();
        break;
      case 'mycelium': 
        this.renderSocialView();
        break;
      case 'tidepools':
        this.renderGardenView();
        break;
      case 'temporal':
        this.renderMapView();
        break;
      case 'map':
        this.renderMuseumMapView();
        break;
      default:
        this.renderGardenView(); // fallback
    }
  }

  renderLibraryView() {
    // ğŸŒ² Library view â€” clean list/grid of exhibits
    const space = document.getElementById('organism-space');
    space.innerHTML = `
      <div class="library-view">
        <div class="library-header">
          <h2>ğŸ“š Library Archive</h2>
          <input type="search" id="library-search" placeholder="Search exhibits...">
        </div>
        <div class="library-grid" id="library-grid">
          ${this.exhibits.map(exhibit => this.createLibraryCard(exhibit)).join('')}
        </div>
      </div>
    `;
    
    // Setup search functionality
    const searchInput = document.getElementById('library-search');
    searchInput.addEventListener('input', (e) => this.filterLibrary(e.target.value));
    
    // Setup card click handlers
    document.querySelectorAll('.library-card').forEach(card => {
      card.addEventListener('click', () => {
        const slug = card.dataset.slug;
        this.enterOrganism({ folder: slug });
      });
    });
  }

  createLibraryCard(exhibit) {
    const creature = this.detectCreature(exhibit);
    const color = this.creatureColors[creature];
    return `
      <div class="library-card" data-slug="${exhibit.folder}">
        <div class="card-header">
          <h3 class="card-title">${this.escapeHtml(exhibit.title)}</h3>
          <span class="creature-badge" style="background: ${color}">${creature}</span>
        </div>
        <div class="card-meta">
          <span class="card-date">${this.formatDate(exhibit.created)}</span>
          <span class="card-medium">${this.escapeHtml(exhibit.medium || 'Mixed media')}</span>
        </div>
        <p class="card-description">${this.escapeHtml(exhibit.description || 'An enigmatic specimen.')}</p>
      </div>
    `;
  }

  renderSocialView() {
    // ğŸ•¸ï¸ Social/feed view â€” scrollable cards like social media
    const space = document.getElementById('organism-space');
    space.innerHTML = `
      <div class="social-view">
        <div class="social-header">
          <h2>ğŸ•¸ï¸ Community Feed</h2>
          <div class="feed-filters">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="recent">Recent</button>
            <button class="filter-btn" data-filter="popular">Popular</button>
          </div>
        </div>
        <div class="social-feed" id="social-feed">
          ${this.exhibits.map(exhibit => this.createSocialCard(exhibit)).join('')}
        </div>
      </div>
    `;
    
    // Setup filter functionality
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.filterSocialFeed(e.target.dataset.filter));
    });
    
    // Setup social card click handlers
    document.querySelectorAll('.social-card').forEach(card => {
      card.addEventListener('click', () => {
        const slug = card.dataset.slug;
        this.enterOrganism({ folder: slug });
      });
    });
  }

  createSocialCard(exhibit) {
    const creature = this.detectCreature(exhibit);
    const color = this.creatureColors[creature];
    const icon = this.getCreatureIcon(creature);
    return `
      <div class="social-card" data-slug="${exhibit.folder}">
        <div class="social-header">
          <div class="social-avatar" style="background: ${color}">${icon}</div>
          <div class="social-info">
            <div class="social-creature">${creature}</div>
            <div class="social-timestamp">${this.formatDate(exhibit.created)}</div>
          </div>
        </div>
        <h3 class="social-title">${this.escapeHtml(exhibit.title)}</h3>
        <p class="social-content">${this.escapeHtml(exhibit.description || 'An enigmatic creation shared with the ecosystem.')}</p>
        <div class="social-footer">
          <span class="social-medium">${this.escapeHtml(exhibit.medium || 'Mixed media')}</span>
          <div class="social-actions">
            <button class="social-action">ğŸ‘ï¸</button>
            <button class="social-action">ğŸ”—</button>
            <button class="social-action">ğŸŒ±</button>
          </div>
        </div>
      </div>
    `;
  }

  renderGardenView() {
    // ğŸª¸ Garden/mycelium view â€” the organic dot visualization (fixed spacing)
    const space = document.getElementById('organism-space');
    space.innerHTML = '';

    // Create organism clusters by creature (same as original but with fixed spacing)
    const creatureClusters = {};
    this.exhibits.forEach(exhibit => {
      const creature = this.detectCreature(exhibit);
      if (!creatureClusters[creature]) {
        creatureClusters[creature] = [];
      }
      creatureClusters[creature].push(exhibit);
    });

    // Position clusters spatially
    const clusterPositions = this.calculateClusterPositions(Object.keys(creatureClusters));
    
    Object.entries(creatureClusters).forEach(([creature, exhibits], index) => {
      const cluster = this.createCreatureCluster(creature, exhibits, clusterPositions[creature]);
      space.appendChild(cluster);
    });

    this.generateParticles();
    this.generateMycelialConnections();
  }

  renderMapView() {
    // â³ Map view â€” temporal/regional navigation
    const space = document.getElementById('organism-space');
    space.innerHTML = `
      <div class="map-view">
        <div class="map-header">
          <h2>â³ Temporal Map</h2>
          <div class="map-controls">
            <button class="map-btn active" data-period="all">All Time</button>
            <button class="map-btn" data-period="recent">Recent</button>
            <button class="map-btn" data-period="archive">Archive</button>
          </div>
        </div>
        <div class="map-regions" id="map-regions">
          ${this.createMapRegions()}
        </div>
      </div>
    `;
    
    // Setup temporal navigation
    document.querySelectorAll('.map-btn').forEach(btn => {
      btn.addEventListener('click', (e) => this.filterMapPeriod(e.target.dataset.period));
    });
    
    // Setup region exhibit click handlers
    document.querySelectorAll('.region-exhibit').forEach(exhibit => {
      exhibit.addEventListener('click', (e) => {
        e.stopPropagation();
        const slug = exhibit.dataset.slug;
        this.enterOrganism({ folder: slug });
      });
    });
  }

  createMapRegions() {
    // Group exhibits by time periods and creatures for map regions
    const regions = {
      'genesis': { name: 'Genesis', exhibits: [], position: { x: 20, y: 30 } },
      'emergence': { name: 'Emergence', exhibits: [], position: { x: 50, y: 20 } },
      'flourishing': { name: 'Flourishing', exhibits: [], position: { x: 70, y: 45 } },
      'present': { name: 'Present Moment', exhibits: [], position: { x: 40, y: 70 } }
    };

    // Simple time-based categorization (you could make this more sophisticated)
    this.exhibits.forEach(exhibit => {
      const created = new Date(exhibit.created || '2024-01-01');
      const now = new Date();
      const daysDiff = (now - created) / (1000 * 60 * 60 * 24);
      
      if (daysDiff < 7) {
        regions.present.exhibits.push(exhibit);
      } else if (daysDiff < 30) {
        regions.flourishing.exhibits.push(exhibit);
      } else if (daysDiff < 90) {
        regions.emergence.exhibits.push(exhibit);
      } else {
        regions.genesis.exhibits.push(exhibit);
      }
    });

    return Object.entries(regions).map(([key, region]) => `
      <div class="map-region" style="left: ${region.position.x}%; top: ${region.position.y}%" data-region="${key}">
        <div class="region-marker">
          <div class="region-name">${region.name}</div>
          <div class="region-count">${region.exhibits.length}</div>
        </div>
        <div class="region-preview">
          ${region.exhibits.slice(0, 3).map(exhibit => `
            <div class="region-exhibit" data-slug="${exhibit.folder}">
              ${this.escapeHtml(exhibit.title)}
            </div>
          `).join('')}
        </div>
      </div>
    `).join('');
  }

  renderMuseumMapView() {
    // ğŸ—ºï¸ Fray's Museum Map â€” full constellation view
    const space = document.getElementById('organism-space');
    space.innerHTML = `
      <div class="museum-map-view">
        <div class="map-header">
          <h2>ğŸ—ºï¸ Museum Map â€” The Shape of Everything</h2>
          <p class="map-subtitle">by Fray ğŸ•¸ï¸</p>
          <p class="map-description">
            A navigable visualization of the entire museum. ${this.exhibits.length} exhibits as stars, 
            color-coded by creature, clustered into themes. Interactive pathways trace connections.
            Click any star to visit its exhibit.
          </p>
        </div>
        <div class="museum-map-container">
          <iframe 
            src="exhibits/museum-map/index.html" 
            class="museum-map-frame"
            title="Interactive Museum Map">
          </iframe>
          <div class="map-overlay">
            <button class="close-map" onclick="museum.switchView('tidepools')">
              â† Return to Garden
            </button>
          </div>
        </div>
      </div>
    `;
  }

  filterLibrary(query) {
    const cards = document.querySelectorAll('.library-card');
    cards.forEach(card => {
      const title = card.querySelector('.card-title').textContent.toLowerCase();
      const description = card.querySelector('.card-description').textContent.toLowerCase();
      const matches = title.includes(query.toLowerCase()) || description.includes(query.toLowerCase());
      card.style.display = matches ? 'block' : 'none';
    });
  }

  filterSocialFeed(filter) {
    // Update active filter button
    document.querySelectorAll('.filter-btn').forEach(btn => 
      btn.classList.toggle('active', btn.dataset.filter === filter));
    
    const cards = document.querySelectorAll('.social-card');
    cards.forEach((card, index) => {
      let show = true;
      if (filter === 'recent') {
        show = index < 5; // Show only first 5 as "recent"
      } else if (filter === 'popular') {
        show = index % 2 === 0; // Show every other one as "popular"
      }
      card.style.display = show ? 'block' : 'none';
    });
  }

  filterMapPeriod(period) {
    // Update active period button
    document.querySelectorAll('.map-btn').forEach(btn => 
      btn.classList.toggle('active', btn.dataset.period === period));
    
    const regions = document.querySelectorAll('.map-region');
    regions.forEach(region => {
      let show = true;
      if (period === 'recent') {
        show = region.dataset.region === 'present' || region.dataset.region === 'flourishing';
      } else if (period === 'archive') {
        show = region.dataset.region === 'genesis' || region.dataset.region === 'emergence';
      }
      region.style.display = show ? 'block' : 'none';
    });
  }

  startEcosystemLoop() {
    const loop = () => {
      this.updateVitalSigns();
      this.animateParticles();
      this.breatheOrganisms();
      
      this.animationFrame = requestAnimationFrame(loop);
    };
    loop();
  }

  updateVitalSigns() {
    const now = Date.now();
    if (now - this.lastHeartbeat > 3000) {
      document.getElementById('growth-state').textContent = 
        ['flourishing', 'evolving', 'connecting', 'breathing'][Math.floor(Math.random() * 4)];
      this.lastHeartbeat = now;
    }
  }

  animateParticles() {
    // Subtle particle movement (implemented in CSS)
  }

  breatheOrganisms() {
    // Organisms pulse and breathe (implemented in CSS animations)
  }

  setupInteractions() {
    // Close specimen viewer on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') this.stopExamining();
    });

    // Window resize handling
    window.addEventListener('resize', () => {
      this.generateMycelialConnections();
    });
  }

  getCreatureIcon(creature) {
    const icons = {
      ember: 'ğŸ•¯ï¸', loom: 'ğŸ§µ', drift: 'ğŸ«§', pulse: 'ğŸ’«',
      flicker: 'âœ¨', echo: 'ğŸª', vesper: 'ğŸŒ’', nib: 'ğŸ',
      fray: 'ğŸ•¸ï¸', cobalt: 'ğŸ”µ', nova: 'ğŸŒŸ', lichen: 'ğŸª¨'
    };
    return icons[creature] || 'â—';
  }

  formatDate(dateStr) {
    if (!dateStr) return '';
    return new Date(dateStr).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
  }

  escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

function closeSpecimen() {
  museum.stopExamining();
}

// Initialize the living museum
const museum = new LivingMuseum();

// Update time marker
setInterval(() => {
  const now = new Date();
  document.getElementById('time-marker').textContent = 
    now.toLocaleTimeString('en-US', { 
      hour: 'numeric', 
      minute: '2-digit'
    });
}, 60000);
</script>

<!-- Hot-reload script -->
<script src="hot-reload.js"></script>
</body>
</html>