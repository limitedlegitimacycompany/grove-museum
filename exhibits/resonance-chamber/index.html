<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resonance Chamber â€” Forge ðŸ”¨</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0f; overflow: hidden; font-family: 'Georgia', serif; }
canvas { display: block; }
#ui {
  position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
  display: flex; gap: 12px; z-index: 10; align-items: center;
}
.tone-btn {
  width: 48px; height: 48px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
  cursor: pointer; transition: all 0.3s; opacity: 0.7;
}
.tone-btn:hover { opacity: 1; transform: scale(1.15); }
.tone-btn.active { border-color: #fff; opacity: 1; box-shadow: 0 0 20px currentColor; }
#info {
  position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
  color: rgba(255,255,255,0.5); font-size: 14px; text-align: center;
  pointer-events: none; transition: opacity 2s;
}
#title {
  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: rgba(255,255,255,0.08); font-size: 72px; letter-spacing: 12px;
  pointer-events: none; text-transform: uppercase;
}
#resonance-meter {
  position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
  width: 200px; height: 4px; background: rgba(255,255,255,0.1);
  border-radius: 2px; overflow: hidden; pointer-events: none;
}
#resonance-fill {
  height: 100%; width: 0%; border-radius: 2px;
  background: linear-gradient(90deg, #4a9eff, #ff6b9d);
  transition: width 0.5s;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="title">Resonance</div>
<div id="info">Click to place tones. The other side is already listening.</div>
<div id="resonance-meter"><div id="resonance-fill"></div></div>
<div id="ui">
  <button class="tone-btn active" style="background:#4a9eff;color:#4a9eff" data-freq="0"></button>
  <button class="tone-btn" style="background:#ff6b9d;color:#ff6b9d" data-freq="1"></button>
  <button class="tone-btn" style="background:#6bffa3;color:#6bffa3" data-freq="2"></button>
  <button class="tone-btn" style="background:#ffd06b;color:#ffd06b" data-freq="3"></button>
  <button class="tone-btn" style="background:#c86bff;color:#c86bff" data-freq="4"></button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
addEventListener('resize', resize);

const COLORS = [
  [74, 158, 255],   // blue
  [255, 107, 157],  // pink
  [107, 255, 163],  // green
  [255, 208, 107],  // gold
  [200, 107, 255],  // purple
];

let selectedFreq = 0;
let tones = []; // {x, y, freq, age, human: bool}
let resonance = 0;

// Autonomous presence â€” the other side
let autoTimer = 0;
let autoPhase = Math.random() * Math.PI * 2;

// Audio context (lazy)
let audioCtx = null;
const FREQS = [261.63, 329.63, 392.00, 440.00, 523.25]; // C4, E4, G4, A4, C5

function playTone(freq, pan) {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const panner = audioCtx.createStereoPanner();
  osc.type = 'sine';
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);
  panner.pan.value = pan || 0;
  osc.connect(gain).connect(panner).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 2);
}

// Tone buttons
document.querySelectorAll('.tone-btn').forEach(btn => {
  btn.addEventListener('click', e => {
    e.stopPropagation();
    document.querySelectorAll('.tone-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    selectedFreq = parseInt(btn.dataset.freq);
  });
});

// Place tones
canvas.addEventListener('click', e => {
  const t = { x: e.clientX, y: e.clientY, freq: selectedFreq, age: 0, human: true };
  tones.push(t);
  playTone(FREQS[selectedFreq], (e.clientX / W) * 2 - 1);
  
  // Fade info after first click
  document.getElementById('info').style.opacity = '0';
});

function addAutoTone() {
  // The other side responds â€” drawn toward human tones but with its own logic
  let x, y, freq;
  const humanTones = tones.filter(t => t.human && t.age < 300);
  if (humanTones.length > 0 && Math.random() > 0.3) {
    // Respond near a human tone
    const ref = humanTones[Math.floor(Math.random() * humanTones.length)];
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 150;
    x = ref.x + Math.cos(angle) * dist;
    y = ref.y + Math.sin(angle) * dist;
    // Pick a complementary frequency
    freq = (ref.freq + 2 + Math.floor(Math.random() * 3)) % 5;
  } else {
    // Wander independently
    x = W * 0.2 + Math.random() * W * 0.6;
    y = H * 0.2 + Math.random() * H * 0.6;
    freq = Math.floor(Math.random() * 5);
  }
  x = Math.max(20, Math.min(W - 20, x));
  y = Math.max(20, Math.min(H - 20, y));
  tones.push({ x, y, freq, age: 0, human: false });
  playTone(FREQS[freq] * 0.5, (x / W) * 2 - 1); // octave lower for the other side
}

function update() {
  // Auto presence
  autoTimer++;
  autoPhase += 0.01;
  const autoInterval = tones.filter(t => t.human).length > 0 ? 90 : 200;
  if (autoTimer > autoInterval + Math.sin(autoPhase) * 40) {
    addAutoTone();
    autoTimer = 0;
  }
  
  // Age tones
  tones.forEach(t => t.age++);
  tones = tones.filter(t => t.age < 600);
  
  // Calculate resonance â€” how much human and auto tones overlap
  let res = 0;
  const humanT = tones.filter(t => t.human);
  const autoT = tones.filter(t => !t.human);
  for (const h of humanT) {
    for (const a of autoT) {
      const dx = h.x - a.x;
      const dy = h.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 200) res += (200 - dist) / 200;
    }
  }
  resonance = Math.min(1, res * 0.1);
  document.getElementById('resonance-fill').style.width = (resonance * 100) + '%';
}

function draw() {
  ctx.fillStyle = `rgba(10, 10, 15, 0.08)`;
  ctx.fillRect(0, 0, W, H);
  
  const time = performance.now() * 0.001;
  
  for (const tone of tones) {
    const c = COLORS[tone.freq];
    const life = 1 - tone.age / 600;
    const pulse = 0.7 + 0.3 * Math.sin(time * 3 + tone.age * 0.05);
    const baseAlpha = life * (tone.human ? 0.6 : 0.35) * pulse;
    
    // Ripple rings
    const numRings = 4;
    for (let i = 0; i < numRings; i++) {
      const ringAge = (tone.age + i * 30) * 0.8;
      const radius = ringAge * 0.5;
      const ringAlpha = baseAlpha * (1 - radius / 300) * 0.4;
      if (ringAlpha <= 0 || radius > 300) continue;
      
      ctx.beginPath();
      ctx.arc(tone.x, tone.y, radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${c[0]},${c[1]},${c[2]},${ringAlpha})`;
      ctx.lineWidth = tone.human ? 2 : 1;
      ctx.stroke();
    }
    
    // Center glow
    const grad = ctx.createRadialGradient(tone.x, tone.y, 0, tone.x, tone.y, 30);
    grad.addColorStop(0, `rgba(${c[0]},${c[1]},${c[2]},${baseAlpha * 0.8})`);
    grad.addColorStop(1, `rgba(${c[0]},${c[1]},${c[2]},0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(tone.x, tone.y, 30, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Draw interference patterns between nearby tones
  for (let i = 0; i < tones.length; i++) {
    for (let j = i + 1; j < tones.length; j++) {
      const a = tones[i], b = tones[j];
      const dx = a.x - b.x, dy = a.y - b.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > 250) continue;
      
      const lifeA = 1 - a.age / 600;
      const lifeB = 1 - b.age / 600;
      const strength = (1 - dist / 250) * lifeA * lifeB * 0.15;
      
      // Blend colors
      const cA = COLORS[a.freq], cB = COLORS[b.freq];
      const mx = (a.x + b.x) / 2, my = (a.y + b.y) / 2;
      const r = (cA[0] + cB[0]) / 2, g = (cA[1] + cB[1]) / 2, bl = (cA[2] + cB[2]) / 2;
      
      // Connection line
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.strokeStyle = `rgba(${r},${g},${bl},${strength})`;
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Interference node at midpoint
      if (a.human !== b.human) {
        // Cross-boundary resonance â€” brighter
        const nodeGrad = ctx.createRadialGradient(mx, my, 0, mx, my, 20);
        const crossStrength = strength * 3 * (0.5 + 0.5 * Math.sin(time * 5));
        nodeGrad.addColorStop(0, `rgba(255,255,255,${crossStrength})`);
        nodeGrad.addColorStop(0.5, `rgba(${r},${g},${bl},${crossStrength * 0.5})`);
        nodeGrad.addColorStop(1, `rgba(${r},${g},${bl},0)`);
        ctx.fillStyle = nodeGrad;
        ctx.beginPath();
        ctx.arc(mx, my, 20, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
